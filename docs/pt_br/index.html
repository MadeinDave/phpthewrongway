<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="A maneira errada">
  <title>PHP - A maneira errada</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="/css/html.css">
<meta name="description" content="Esse website foi criado numa tentativa de apresentar uma visão pragmática sobre a programação PHP. Uma visão ditada pela experiência consequências práticas ao invés de tendências populares, teorias, ou dogmas acadêmicos.">
</head>
<body>
<header>
<div id="header-top">
<a href="https://github.com/unixsheikh/phpthewrongway"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/652c5b9acfaddf3a9c326fa6bde407b87f7be0f4/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6f72616e67655f6666373630302e706e67" alt="Fork me on GitHub" data-canonical-src="/img/github-clone.png"></a>
<h1>PHP</h1>
<h2>A maneira errada</h2>
<div id="date">Última atualização: 2020-05-20</div>
</div>
</header>
<div id="cartoon">
<img src="/img/deviant-code-1000px-pt_br.png" alt="cartoon">
</div>
<nav id="TOC">
<ul>
<li><a href="#bem-vindo">Bem-vindo</a>
<ul>
<li><a href="#traduções">Traduções</a></li>
</ul></li>
<li><a href="#o-perigo-do-extremismo">O perigo do extremismo</a></li>
<li><a href="#sempre-use-um-framework">Sempre use um ‘framework’</a></li>
<li><a href="#sempre-use-padrões-de-projeto-design-pattern">Sempre use Padrões de Projeto (Design Pattern)</a></li>
<li><a href="#sempre-use-orientação-a-objetos">Sempre use orientação a objetos</a>
<ul>
<li><a href="#a-small-history-lesson">A small history lesson</a></li>
</ul></li>
<li><a href="#ter-medo-do-código-de-outras-pessoas">Ter medo do código de outras pessoas</a></li>
<li><a href="#following-the-php-fig-standards-religiously">Following the PHP-FIG standards religiously</a></li>
<li><a href="#negligenciar-a-segurança">Negligenciar a segurança</a>
<ul>
<li><a href="#seguro-por-padrão">Seguro por padrão</a></li>
</ul></li>
<li><a href="#faq">FAQ</a></li>
<li><a href="#leitura-recomendada">Leitura recomendada</a></li>
<li><a href="#como-contribuir">Como contribuir</a></li>
</ul>
</nav>
<h1 id="bem-vindo">Bem-vindo</h1>
<p>No mundo da programação PHP um conjunto de tendências estão sendo massivamente propagadas por algumas pessoas (em seus livros e websites) como “PHP Moderno” enquanto todas as outras abordagens são vistas como atrasadas, estúpidas, ou simplesmente erradas.</p>
<p>Essas pessoas parecem trabalhar incansavelmente no sentido de conseguir que as outras pessoas sigam sua maneira de fazer as coisas.</p>
<p>Esse website foi criado numa tentativa de apresentar uma visão pragmática sobre a programação PHP. Uma visão ditada pela experiência e consequências práticas ao invés de tendências populares, teorias, ou dogmas acadêmicos.</p>
<p>O website <a href="http://www.phpthewrongway.com/">PHP - The Wrong Way</a> é um documento livre e continuará sendo atualizado com mais informações assim que estiverem disponíveis.</p>
<p>Sinta-se livre para contribuir.</p>
<h2 id="traduções">Traduções</h2>
<ul>
<li><a href="http://www.phpthewrongway.com/da/">Dinamarquês</a></li>
<li><a href="http://www.phpthewrongway.com/es/">Espanhol</a></li>
<li><a href="http://www.phpthewrongway.com/fr/">Francês</a></li>
<li><a href="http://www.phpthewrongway.com/ja/">Japonês</a></li>
<li><a href="http://www.phpthewrongway.com/">Inglês</a></li>
<li><a href="http://www.phpthewrongway.com/fa/">Persa</a></li>
<li><a href="http://www.phpthewrongway.com/pt_BR/">Português</a></li>
<li><a href="http://www.phpthewrongway.com/ru/">Russo</a></li>
<li><a href="http://www.phpthewrongway.com/tr/">Türkçe</a></li>
</ul>
<h1 id="o-perigo-do-extremismo">O perigo do extremismo</h1>
<p>Um problema com regras e diretrizes na programação é que elas geralmente só servem a um propósito em um contexto específico. Saindo desse contexto, uma boa regra pode se tornar uma regra horrível. De fato, toda boa regra se torna ruim quando levada ao extremo.</p>
<p>Isso é importante entender porque muitos princípios e regras do desenvolvimento de software desenvolvidas ao longo do tempo e apresentadas por diferentes pessoas frequentemente se tornam mal utilizadas nas mãos de extremistas.</p>
<p>Experience has taught that misuse of general rules and guidelines always results in complication, lack of security, error-prone results, and in some cases complete and utter disaster.</p>
<p>A experiência ensinou que o uso indevido de regras e diretrizes gerais sempre resulta em complicações, falta de segurança, resultados propensos a erros e, em alguns casos, desastre total e completo.</p>
<p>O <a href="https://en.wikipedia.org/wiki/KISS_principle">princípio KISS</a>, que é um acrônimo para “Keep It Simple, Stupid”, é um bom e extremamente sábio princípio que geralmente é visto por pessoas experientes como um conselho muito bom a seguir, mas mesmo este grande princípio torna-se um perigo para um projeto, se levado ao extremo. Existe tal coisa como “muito simples” resultando em falta de funcionalidade necessária.</p>
<p><strong>A maneira errada</strong>: Aplicação religiosa de regras e diretrizes. <img src="/img/thumbs-down.png" alt="Thumbs down" /></p>
<h1 id="sempre-use-um-framework">Sempre use um ‘framework’</h1>
<blockquote>
<p>Todas as estruturas de uso geral (‘frameworks’) são uma merda!</p>
<p>– <a href="https://www.youtube.com/watch?v=DuB6UjEsY_Y">Rasmus Lerdorf</a></p>
</blockquote>
<p>Na comunidade PHP uma tendência muito ruim se tornou um padrão para o desenvolvimento de aplicações ‘Web’, e isso é pelo uso de um ‘framework’ popular.</p>
<p>Essa tendência surgiu e se tornou popular, não porque de alguma forma melhore o resultado do processo de desenvolvimento ou é a coisa certa a se fazer do ponto de vista da tecnologia e da arquitetura. Essa tendência se tornou popular porque alguns dos desenvolvedores que trabalham com ‘frameworks’ conseguiram espalhar para um grande público a polêmica opinião contra a programação do zero, usando frases como “Não reinvente a roda!” e “Não faça você mesmo, os outros são mais hábeis que você”.</p>
<p>Muitos dos programadores de hoje ignoram completamente os princípios fundamentais da programação e passam muito tempo fantasiando novas camadas de complexidade, de modo a parecerem mais inteligentes, mais legais e mais aceitáveis ​​em seu meio.</p>
<p>Essas pessoas parecem estar apaixonadas pelo pensamento de fazer com que outras sigam a sua “maneira de fazer as coisas”, tornando-se algum líder da comunidade PHP e fazendo com que outras pessoas usem suas mais recentes ferramentas de código-fonte “modernas”, que esquecem de garantir que os conselhos que estão dando são sólidos.</p>
<p>Nessa indústria de ‘software’ você pode comparar uma casa pré-construída com um ‘framework’. Construir um ‘software’ usando um ‘framework’ faz de você um desenvolvedor ou programador que monta uma casa já pronta, um carpinteiro.</p>
<p>Nesse ‘site’, nós diferenciamos ‘frameworks’ de bibliotecas dessa maneira:</p>
<ul>
<li>Uma biblioteca é considerada uma coleção de códigos reutilizáveis, como a biblioteca padrão C, ou a biblioteca padrão Go. Consiste no código que você facilmente integra no seu projeto sem impor nenhuma limitação ou restrição. Consiste em pequenos pedaços de código com uma funcionalidade específica.</li>
<li>Um ‘framework’ não é uma coleção de códigos reutilizáveis: você não pode simplesmente pegar um pedaço de código do ‘framework’ e integrar dentro do seu projeto. Um ‘framework’ é um sistema que ajuda você a construir um ‘software’, mas, ao mesmo tempo te força nas limitações e restrições do prórprio ‘framework’. O ‘framework’ tem muitas funcionalidades que se interdependem. Um pedaço não pode trabalhar sem outro.</li>
</ul>
<p>No mundo do Python e Ruby, construir um ‘site’ do zero é cansativo, porque nem o Python e nem o Ruby foi originado para criação de ‘sites’. Como resultado, ‘frameworks’ como o <a href="https://en.wikipedia.org/wiki/Django_%28web_framework%29">Django</a> e o <a href="https://en.wikipedia.org/wiki/Ruby_on_Rails">Ruby on Rails</a> rapidamente se tornaram porpulares entre os desenvolvedores de ‘sites’ dessas linguagens.</p>
<p>O PHP, no entanto foi criado desde o início por Rasmus Lerdorf como um conjunto de ferramentas escritas em C que permitiam desenvolver de forma fácil e rápida um HTML dinâmico. Como tal, PHP era, e ainda é, <strong>um ‘framework’ por si só</strong>.</p>
<p>O PHP evoluiu bastante desde então, e hoje o PHP pode ser para mais do que construir ‘sites’, mas olhar para o PHP como um ‘framework’ não é errado. PHP é por natureza uma camada de abstração para desenvolvimento de aplicações ‘web’ escritos inteiramente em C procedural.</p>
<p>Usar uma biblioteca dentro do seu projeto é normal. O próprio PHP vem com um conjunto de bibliotecas que você pode usar para estender para seu código. O PDO, por exemplo, é uma leve biblioteca que fornece uma interface consistente para conectar ao banco de dados pelo PHP.</p>
<p>Usar um ‘framework’ por cima do PHP é outra coisa.</p>
<p>Quando você usa um ‘framework’ no PHP, você adiciona uma camada de abstração em cima de outra camada de abstração, uma que já foi colocada para você no início. Adicionada a segunda camada de abstração, ou seja, o ‘framework’ pode simplesmente servir para organizar o seu código em um conjunto de padrões pré-fixados, ou pode adicionar ainda mais complexidade entrelaçando centenas, ou até milhares de classes e métodos dentro de um pesadelo de dependências. De qualquer maneira você está adicionando camadas de complexidade para seu código que não são necessárias.</p>
<p>Toda a experiência começa com a interface. A experiência da interface é o resultado da tecnologia subjacente e da quantidade de camadas de abstração. Quanto mais abstração você usa, menos eficiente a interface se torna e mais suscetível a erros a aplicação se torna. Quanto maior a abstração, mais detalhes e eficiência são perdidos.</p>
<p>Entenda isso claramente: <strong>O número ideal de linhas de código em qualquer projeto é o mínimo possível, ao mesmo tempo que é o mais claro e legível possível!</strong></p>
<blockquote>
<p>O que todo mundo não precisa é de um ‘framework’ genérico. Ninguém tem um problema genérico, todo mundo tem um problema muito específico que está tentando resolver.</p>
<p>– <a href="https://www.youtube.com/watch?v=anr7DQnMMs0">Rasmus Lerdorf</a></p>
</blockquote>
<p>Algumas empresas começaram a ouvir o borborinho sobre os ‘frameworks’ PHP e elas começaram seus projetos com esses ‘frameworks’ genéricos só para ver esses projetos acabarem em um desastre. Eles não apenas descobriram que um ‘framework’ genérico era muito ruim para resolver suas necessidades muito específicas, mas eles eram extremamente lentos em fazê-los. Era impossível escalar, e como resultado, eles começaram a mexer no ‘framework’ a parte, numa tentativa desesperada de retirar todas as coisas que realmente não precisavam.</p>
<p>Sempre use a abordagem pragmática:</p>
<blockquote>
<p>Ação ou política ditada pela consideração das consequências práticas imediatas ao invés de pôr teoria ou dogma.</p>
<p>– Collins English Dictionary, Complete and Unabridged, 12th Edition 2014</p>
</blockquote>
<p><strong>A maneira errada:</strong> Sempre use um ‘framework’ em cima do PHP. <img src="/img/thumbs-down.png" alt="Thumbs down" /></p>
<h1 id="sempre-use-padrões-de-projeto-design-pattern">Sempre use Padrões de Projeto (Design Pattern)</h1>
<blockquote>
<p>Tenho uma grande alergia aos Padrões de Projeto (Design Pattern). Peter Norvig, quando estava na Harlequin, ele escreveu esse artigo sobre como os padrões de projetos são apenas falhas nas suas linguagens de programação. Pegue uma linguagem de programação melhor. Ele estava absolutamente certo. Adorando padrões de e pensando “Oh! Vou usar o padrão X.”</p>
</blockquote>
<blockquote>
<p>– Brendan Eich em <a href="http://codersatwork.com/">Coders at work - Reflections on the Craft of Programming</a></p>
</blockquote>
<p>Na engenharia de ‘software’, um padrão de projeto é uma solução reutilizável para um problema no ‘design’ de ‘software’. Um padrão de projeto não é um ‘design’ acabado que pode ser transformado diretamente em código. É uma descrição ou uma ideia de como solucionar um problema que pode vir a aparecer em muitas situações diferentes. Orientação a Objetos tipicamente demonstra relações e interações entre classes e objetos, sem especificar a aplicação final destes que estão envolvidos.</p>
<p>O PHP suporta paradigmas imperativos, funcionais, orientados a objetos, procedural e paradigmas reflexivos. O PHP é uma enorme caixa de ferramentas que faz o possível para solucionar muitos problemas de maneiras diferentes - não de um único jeito.</p>
<p>O PHP disponibiliza liberdade, soluções rápidas e escaláveis, e muitas outras maneiras diferentes de lidar com os problemas.</p>
<p>Quando tenta melhorar a si mesmo, e, neste caso, mais especificamente o código, às vezes fica-se presos a filosofia de um padrão ou ideia e tende-se a esquecer das situações que possuem suas próprias particularidades.</p>
<blockquote>
<p>Quando vejo um padrão de projeto em meu programa, considero um sinal de problema. A forma de programar deve refletir somente os problemas que precisam de solução. Qualquer outra regularidade é um sinal, pelo menos pra mim, que estou usando abstrações que não são suficientes - frequentemente estou gerando manualmente algumas expansões macro que eu preciso escrever.</p>
<p>– <a href="http://c2.com/cgi/wiki?AreDesignPatternsMissingLanguageFeatures">Paul Graham</a></p>
</blockquote>
<p>Não se deve agarrar em uma filosofia ou ideia por trás de um padrão específico ou solução. A principal preocupação é manter o código fácil de navegar e entender o máximo possível e como resultado, será manutenível e seguro.</p>
<p>Deve-se lembrar sempre que existem antipadrões. É um padrão comumente utilizado, mas é ineficiente e/ou contraprodutivo na prática.</p>
<blockquote>
<p>Penso que os padrões começaram como melhores soluções para problemas comuns. Mas agora eles já existem há um tempo e temos experienciado aplicativos feitos dez vezes mais complicados que eles necessitavam, por conta das pessoas tentarem se concentrar em todos os padrões sobre os quais leram (“minha aplicação está muito bem arquitetada, porque é feita com padrões de projetos.”) minha impressão do valor de um padrão de projeto mudou um pouco.</p>
<p>– Paul Weaton in <a href="http://www.javaranch.com/patterns/">Evil Design Patterns</a></p>
</blockquote>
<p>Sempre use a abordagem pragmática:</p>
<blockquote>
<p>Ação ou política ditada pela consideração das consequências práticas imediatas ao invés de pôr teoria ou dogma.</p>
<p>– Collins English Dictionary, Complete and Unabridged, 12th Edition 2014</p>
</blockquote>
<p><strong>A maneira errada</strong>: Procure um padrão de projeto para resolver um problema. <img src="/img/thumbs-down.png" alt="Thumbs down" /></p>
<h1 id="sempre-use-orientação-a-objetos">Sempre use orientação a objetos</h1>
<blockquote>
<p>The problem with object-oriented languages is they’ve got all this implicit environment that they carry around with them. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.</p>
<p>– Joe Armstrong in <a href="http://codersatwork.com/">Coders at work - Reflections on the Craft of Programming</a></p>
</blockquote>
<blockquote>
<p>Abstraction is powerful. What I’m really allergic to, and what I had a reaction to in the ’90s, was all the CORBA, COM, DCOM, object-oriented nonsense. Every startup of the day had some crazy thing that would take 200.000 method calls to start up and print “Hello world”. That’s a travesty! You don’t want to be a programmer associated with that sort of thing.</p>
<p>– Brendan Eich in <a href="http://codersatwork.com/">Coders at work - Reflections on the Craft of Programming</a></p>
</blockquote>
<p>Many software developers, and many companies, feel that object-oriented programming is the only reasonable way to develop software today. Any one who argues against object-oriented programming is immediately made conscious of the fact that they are arguing against the “conventional wisdom” of the industry.</p>
<p>On programming blogs and forums, there are a great many people who defend object-oriented programming, and who feel certain that they know what they are talking about, despite the lack of any standard definition!</p>
<p>The fact is that so-called object-oriented programming as such often inflicts a heavy burden of unneeded complexity!</p>
<p>As computer scientists and programmers we must learn to set aside prejudices and find the best solution to a given problem.</p>
<p>Today, one of the main strengths of PHP is its support for both imperative, functional, object-oriented, procedural, and reflective paradigms. PHP is a huge toolbox with lots of different tools that makes it possible to solve many problems in many different ways - <strong>not just one way!</strong></p>
<p><strong>As soon as we try to force-feed different problems within an application to a single specific programming paradigm, we’re not thinking creatively and we’re not working efficiently!</strong></p>
<h2 id="a-small-history-lesson">A small history lesson</h2>
<p>One of the greatest ways to understand a specific programming paradigm is to look at how it first evolved. What was the reason for its development? What problems existed with other programming paradigms that needed a new way of thinking? Was it a real world problem or simply an academic problem? And how has it since evolved?</p>
<p>It doesn’t matter what person X says or what definition person Y gives, what matters in the context of paradigms is the history that made them.</p>
<blockquote>
<p>There are two ways of constructing a software design. One way is to make it so simple that there are obviously no deficiencies. And the other way is to make it so complicated that there are no obvious deficiencies.</p>
<p>– <a href="https://en.wikiquote.org/wiki/C._A._R._Hoare">C.A.R. Hoare</a></p>
</blockquote>
<p>In the past, before the advent of object-oriented programming, around the end of the fifties, much software was developed using programming languages that emphasized unstructured programming, sometimes referred to as first- and second-generation languages. Unstructured programming (or non-structured programming) is historically the earliest programming paradigm. It was heavily criticized for producing “spaghetti” code.</p>
<p>There are both high- and low-level programming languages that use non-structured programming. These include early versions of BASIC, COBOL, MUMPS, JOSS, FOCAL, TELCOMP, machine-level code, early assembler systems (those without procedural meta operators) and some scripting languages.</p>
<p>A program in a non-structured language usually consists of sequentially ordered commands, or statements, usually one in each line. The lines are usually numbered or may have labels which allows the flow of execution to jump to any line in the program (like with the unpopular GOTO statement).</p>
<p>Then, in the sixties, structured programming emerged - mainly due to the famous letter by Edsger W. Dijkstra <a href="http://www.u.arizona.edu/~rubinson/copyright_violations/Go_To_Considered_Harmful.html">Go To statements considered harmful</a>.</p>
<p>Structured programming is a programming paradigm that improves the clarity, quality, and development of software by making use of subroutines, block structures and loops. This is in contrast to using simple jumps such as the GOTO statement.</p>
<p>Later, procedural programming was derived from structured programming. Procedural programming is based upon the concept of “procedure call”. A “procedure call” is just another name for a “function call”. Procedures are also known as routines, subroutines or methods. A procedure simply contain a series of computational steps to be carried out. Any given procedure might be called at any point during a programs execution, including by other procedures or itself.</p>
<p>In the beginning all procedures were available to any part of a program as global data. In small programs this didn’t present a problem, but as things got more complicated and as the size of the program grew, small changes to one part of the program greatly effected many other parts.</p>
<p>Nobody was planning for changes in the program and lots of dependencies existed. A minor change to one procedure would result in a cascade of errors in lots of other procedures that depended on the original code.</p>
<p>A new technique evolved that allowed data to be divided into separated scopes called “objects”. Only specific procedures belonging to the same scope could access the same data. This is called data hiding or encapsulation. The result was much better organized code.</p>
<p>In the beginning objects were not called objects, they were just viewed upon as separate scopes. Later when dependencies were reduced and connections between procedures and variables inside these scopes were viewed upon as isolated segments, the result gave birth to the concepts of “objects” and “object-oriented programming”.</p>
<p>Later, mainly due to the development of Java, certain “buzzwords” arose and “a procedure” or “a function” was no longer called a function, but was renamed “a method” when it resided inside a separate scope. Variables were also no longer called “variables”, but were renamed “attributes” when they resided inside a separate scope.</p>
<p>So an object is in essence simply a collection of functions and variables now called “methods and attributes”.</p>
<p>The way methods and attributes are kept isolated inside a separate scope is by the usage of “a class”. A class, once it is instantiated, is called an object.</p>
<p>Objects can reference each other and by such a reference the methods (functions) inside can “communicate” with each other. Objects can also “inherit” methods from other objects thereby extending such, this is called “inheritance”. It is a way to reuse code and allow independent extensions of the software via public classes and interfaces. The relationships of objects give rise to a hierarchy. Inheritance was invented in 1967 for the programming language <a href="http://en.wikipedia.org/wiki/Simula">Simula 67</a>.</p>
<p>Objects can also inherit methods from other objects and “override” these with added or changed functionality, this is called “polymorphism”.</p>
<p>How these different ideas are implemented vary greatly from programming language to programming language.</p>
<p>Object-oriented programming is about organizing code in another way than before. It is an extension of procedural programming and it is about hiding data (encapsulation) and avoiding a global scope. It is about extending functions by “borrowing” their blueprints without actually affecting the original code (inheritance). And it is about overriding functions without affecting the original code (polymorphism).</p>
<blockquote>
<p>The object-oriented model makes it easy to build up programs by accretion. What this often means, in practice, is that it provides a structured way to write spaghetti code.</p>
<p>– Paul Graham in <a href="https://openlibrary.org/works/OL7944696W/ANSI_Common_Lisp">Ansi Common Lisp</a></p>
</blockquote>
<p><strong>The wrong way</strong>: Always use object-oriented programming. <img src="/img/thumbs-down.png" alt="Thumbs down" /></p>
<h1 id="ter-medo-do-código-de-outras-pessoas">Ter medo do código de outras pessoas</h1>
<p>Um argumento frequentemente expresso para o uso de um framework é que as pessoas não querem lidar com códigos que foram escritos do zero por outras pessoas.</p>
<p>Esta é, no entanto, uma mentalidade estranha, encontrada principalmente entre web developers na comunidade PHP, que exala uma falta de profissionalismo e experiência.</p>
<p>Escrever software e lidar com o código de outras pessoas é normal, é parte do trabalho diário de quem programa profissionalmente, não é algo para se ter medo.</p>
<p>Quem programa profissionalmente não olha para o código de outras pessoas e começa a se lamentar sobre como está à mercê completa do ex-programador, que talvez não esteja mais associado à empresa ou projeto, e se apenas o antigo programador tivesse usado uma estrutura A ou framework B o dia teria sido salvo.</p>
<p>Esta não é a mentalidade de quem programa de maneira profissional. Ninguém faz isso.</p>
<p>Talvez a facilidade de entrada no desenvolvimento web do PHP desempenhe um papel nesse tipo de mentalidade. Independentemente disso, é um sinal de uma pessoa estar na linha errada de trabalho.</p>
<p>Uma grande parte da programação lida com pessoas que precisam trabalhar com código de outras pessoas. Faz parte do trabalho tentar melhorar a base de código existente e, por vezes, isso envolve uma reescrita completa.</p>
<p>Tome nota de pessoas que são grandes referências da programação, leia o livro <a href="http://codersatwork.com/">Coders at work - Reflections on the Craft of Programming</a>.</p>
<p>Algumas das bases de código maiores e mais bem sucedidas do mundo são bases de código que foram desenvolvidas por centenas de pessoas que nunca se conheceram, bases de código desenvolvidas sem o uso de qualquer tipo de framework, bases de código feitas inteiramente em uma linguagem de programação procedural sem o uso de qualquer coisa, mas o paradigma procedural, e eles não sonham em fazê-lo de forma diferente.</p>
<p>O <a href="https://www.kernel.org/">Kernel do Linux</a> consiste em mais de 20 milhões de linhas de código que foram inteiramente escritas utilizando programação procedural por mais de 14.000 pessoas sem o uso de qualquer tipo de framework.</p>
<p>Os diferentes sabores <a href="https://en.wikipedia.org/wiki/Berkeley_Software_Distribution">BSD</a> e a maioria do <a href="https://www.gnu.org/">Linux GNU</a> foram escritos inteiramente usando programação procedural sem o uso de qualquer tipo de framework.</p>
<p>O mesmo vale para centenas de projetos de código aberto em torno desse mundo que acabaram sendo abandonados pela (s) pessoa (s) que os desenvolvia (m) originalmente apenas para serem escolhidos por outras pessoas habilidosas. Muitos desses projetos tinham pouca documentação (se é que tinham alguma), nenhum comentário na base de código e nenhuma orientação ou ajuda para oferecer.</p>
<p>Toda a base de código PHP é feita em C, uma linguagem de programação puramente procedural, sem o uso de qualquer tipo de framework.</p>
<p>A base de código PHP inteira é feita em C, uma linguagem de programação processual pura, sem o uso de qualquer tipo de framework que assim sempre.</p>
<p>Sempre que você define uma classe em PHP ou sempre que usa o seu framework PHP favorito, sua aplicação roda sobre o trabalho puramente procedural de outra pessoa!</p>
<p>Claro, existem coisas como código horrível, código que talvez não tenha sido projetado desde o início, ou código que talvez tenha crescido demais, mas o cliente não queria lidar com uma reescrita, código tão ruim você não pode fazer cara ou coroa dele por mais tempo, mas nenhum tipo de framework teria evitado essa situação. Este é frequentemente o processo natural de crescimento de um programa. Eventualmente, qualquer tipo de estrutura teria sido destruída de qualquer maneira.</p>
<p>E com certeza existe código spagetti horrível, mas ninguém produz um código horrível de propósito. Às vezes isso é resultado da falta de experiência, muitas vezes é culpa do cliente porque ele altera as especificações várias vezes no meio do desenvolvimento, em qualquer um dos dois casos, mesmo que um framework seja usado, o resultado ainda seria código spagetti, e não importa quanto do paradigma orientado a objeto fosse usado, o resultado ainda seria código spagetti.</p>
<p>Como pessoas desenvolvedoras, tentamos evitar essas situações, mas <strong>isso é normal</strong>, isso é <strong>a arte da programação</strong>, isso é parte do que significa <strong>ser uma pessoa que programa</strong>!</p>
<p><strong>O caminho errado</strong>: Ter medo do código de outras pessoas. <img src="/img/thumbs-down.png" alt="Thumbs down" /></p>
<h1 id="following-the-php-fig-standards-religiously">Following the PHP-FIG standards religiously</h1>
<p>The FIG stands for “Framework Interoperability Group”.</p>
<p>The <a href="http://www.php-fig.org/">PHP-FIG</a> was created by a number of framework developers at php|tek in 2009. Since then various other members have applied and been voted in, increasing the size of the group from the first 5 to over 20.</p>
<p>A lot of controversy exists regarding the PHP-FIG. Some people consider the PHP-FIG the best thing that has happened to the PHP community since PHP itself while others considers the group as something best to be forgotten.</p>
<p>One of the problems with PHP-FIG is that it presents itself like this in their <a href="http://www.php-fig.org/faqs/">FAQ</a>:</p>
<blockquote>
<p>The idea behind the group is for project representatives to talk about the commonalities between our projects and find ways we can work together. Our main audience is each other, but we’re very aware that the rest of the PHP community is watching. If other folks want to adopt what we’re doing they are welcome to do so, but that is not the aim. Nobody in the group wants to tell you, as a programmer, how to build your application.</p>
</blockquote>
<p>However, when we view the work of several members of the group, we can clearly see that the objective is quite contrary to the above statement. These members work tirelessly in an attempt to make PHP-FIG become an accepted “PHP standards group”, <strong>which also was the original name of the group</strong>. They do this by classifying the work of the PHP-FIG as “Modern PHP” in their books, on their websites, blog-posts, forums, etc., and by classifying other ways as backwards.</p>
<p>One of the problems with the PHP-FIG is that even though many frameworks and Open Source projects has adopted several of their standards, these standards mainly deal with problems from a “framework perspective”, which renders them pretty unusable in many real-life industry situations.</p>
<p>Many people develop software for the industry that has to be extremely efficient, secure, and cost-effective, software that customers are willing to buy and use. They cannot be bothered with standards that has to conform to the needs of framework fanatics. If they tried to be it would be a disaster for business.</p>
<p>If some kind of standards group needs to be created it has to reflect the interests of the entire PHP community, not just framework and Open Source CMS project developers. It has to be represented by the developers of the PHP programming language itself and it has to be represented by a much larger membership with the right to vote.</p>
<p>If you choose to adopt the standards developed by the PHP-FIG, you have to understand that some of these standards - such as the autoloader standards PSR-0 and PSR-4 and several other standards - has a direct effect upon how you code your software.</p>
<p>Many industries demand highly scalable, run-time critical, and cost-effective software that simply cannot be developed using these standards of the PHP-FIG.</p>
<p><strong>The wrong way</strong>: Following the PHP-FIG religiously. <img src="/img/thumbs-down.png" alt="Thumbs down" /></p>
<h1 id="negligenciar-a-segurança">Negligenciar a segurança</h1>
<blockquote>
<p>O problema com os programadores é que você nunca sabe dizer o que eles estão fazendo, até que seja tarde demais.</p>
<p>– Seymour Cray on <a href="http://www.defprogramming.com/q/6e61ae30a855/">defprogramming.com</a></p>
</blockquote>
<p>A programação segura é a prática de escrever programas que são resistentes ao ataque de pessoas maliciosas ou outros programas. A programação segura ajuda a proteger os dados contra roubo ou corrupção. Além disso, um programa inseguro pode fornecer acesso a um invasor para assumir o controle de um servidor ou a identidade de um usuário, resultando em qualquer coisa, de uma negação de serviço para um usuário ao comprometimento de dados sigilosos, perda de serviço ou danos aos sistemas de milhares de usuários</p>
<p>Todo programa de computador é um alvo em potencial para um ataque de segurança. Os atacantes tentarão encontrar vulnerabilidades de segurança em suas aplicações. Eles tentarão então usar essas vulnerabilidades para roubar ou corromper programas e dados, e ganhar controle de servidores e redes. Os dados de seus clientes e sua reputação estão em jogo.</p>
<p><strong>A segurança não é algo que pode ser adicionado ao software!</strong></p>
<p>Uma aplicação insegura pode exigir um redesenho extenso para protegê-la. Deve-se identificar a natureza das ameaças ao seu software e incorporar práticas de programação seguras antes e durante o planejamento e desenvolvimento de sua aplicação.</p>
<p>Proteger os recursos críticos do software é mais importante do que nunca, pois o foco dos atacantes se moveu constantemente para a camada de aplicação. Um estudo de 2009, da SANS, descobriu que ataques contra aplicações web representam mais de 60% das tentativas de ataque total observadas na Internet.</p>
<p>O PHP é incomum, pois é uma linguagem de programação e uma estrutura da web ao mesmo tempo. Isso significa que o PHP tem muitos recursos da web incorporados a linguagem, o que torna muito fácil escrever um código inseguro.</p>
<h2 id="seguro-por-padrão">Seguro por padrão</h2>
<blockquote>
<p>A complexidade mata. Isso suga a vida dos desenvolvedores, torna os produtos difíceis de planejar, desenvolver e testar, introduz desafios de segurança e causa frustração de usuários finais e administradores.</p>
<p>– <a href="www.azquotes.com/quote/585933">Ray Ozzie</a></p>
</blockquote>
<p>Para que as aplicações sejam projetadas e implementadas com requisitos de segurança adequados, práticas de programação segura e um foco em riscos de segurança devem ser integrados nas operações do dia-a-dia, nos pensamentos e nos próprios processos de desenvolvimento.</p>
<p>Geralmente, é muito mais barato construir software seguro do que corrigir problemas de segurança após o pacote de software ter sido concluído, para não mencionar os custos que podem estar associados a uma violação de segurança.</p>
<p><strong>A maneira errada</strong>: Não desenvolvendo software seguro por padrão. <img src="/img/thumbs-down.png" alt="Thumbs down" /></p>
<h1 id="faq">FAQ</h1>
<p>É fácil interpretar de forma errada um documento escrito, então vamos esclarecer algumas coisas.</p>
<p><strong>P:</strong> <em>Qual é a intenção desse site e por que essa abordagem de confronto?</em></p>
<p><strong>R:</strong> Para criar uma discussão e reflexão sobre as práticas atuais e visões extremas.</p>
<p><strong>P:</strong> <em>Você está dizendo que a programação orientada à objetos é ruim ou errada?</em></p>
<p><strong>R:</strong> Não, claro que não! Nós estamos dizendo que “sempre pensar e sempre usar somente o paradigma de orientação à objetos na resolução de problemas é ruim”. Sempre que você pensa em preto e branco somente, isso é errado.</p>
<p>Mesmo dentro de uma única aplicação existem diferentes problemas. Multi-paradigma é, por vezes, a melhor solução, tudo depende do problema que você está tentando resolver.</p>
<p>Sempre que você força soluções impróprias para um problema específico, coisas ruins acontecem.</p>
<p><strong>P:</strong> <em>Você está dizendo que todos os frameworks são ruins?</em></p>
<p><strong>R:</strong> Nós não estamos tentando julgar frameworks específicos. Estamos lidando com a questão de sempre usar um framework para trabalhar com PHP.</p>
<p><strong>P:</strong> <em>Se um framework pode me ajudar e executa rápido, por que é tão ruim?</em></p>
<p><strong>R:</strong> Se você analisar a situação e as implicações a longo prazo e, em seguida, ver que “executar rapidamente” é o único problema que você sempre tem que lidar, não é ruim, mas então não estamos trabalhando com programação ou desenvolvimento de software, estamos lidando principalmente com soluções “apontar e clicar”.</p>
<p>Executar rapidamente não é projetar um software, isso significa, principalmente, que você não analisou o problema que você está enfrentando e você não ter entendeu as implicações a longo prazo de sua escolha.</p>
<p><strong>P:</strong> <em>Você está dizendo que bibliotecas de terceiros são ruins?</em></p>
<p><strong>R:</strong> Não. Nós estamos promovendo o uso de bibliotecas de terceiros. O código que você pode facilmente integrar em seus próprios projetos sem nunca impor quaisquer limitações ou restrições. Esses são ótimos!</p>
<p><strong>P:</strong> <em>Quem é você?</em></p>
<p><strong>R:</strong> Este site é sobre algumas ideias e sobre combater o extremismo na comunidade PHP, não é sobre a fama pessoal ou reconhecimento. Nomear pessoas só vai mudar o foco dos problemas abordados no site para as pessoas que tratam os problemas. Vamos manter o foco nas idéias.</p>
<p><strong>P:</strong> <em>Qual é a sua experiência no desenvolvimento de software?</em></p>
<p><strong>R:</strong> As ideias, pensamentos e conclusões expressas neste site não necessitam de muita experiência para serem alcançadas, se você apenas manter o foco sobre o tema principal, que é fazer sempre uma coisa em particular porque outras pessoas dizem isso.</p>
<h1 id="leitura-recomendada">Leitura recomendada</h1>
<p><a href="https://news.ycombinator.com/item?id=12318615">PHP The Wrong Way on Hacker News</a></p>
<ul>
<li>When “PHP The Wrong Way” was launched it spawned a bunch of comments on Hacker News that has many valuable arguments worth reading.</li>
</ul>
<p><a href="https://news.ycombinator.com/item?id=12377385">Why bad scientific code beats code following “best practices”</a></p>
<ul>
<li>Simple-minded, care-free near-incompetence can be better than industrial-strength good intentions paving a superhighway to hell. The “real world” outside the computer is full of such examples.</li>
</ul>
<p><a href="https://medium.com/@brianwill/how-to-program-without-oop-74a46e0e47a3#.squpnjz4n">How to program without OOP</a></p>
<ul>
<li>As a fresh and alternative perspective Brian Will discusses in three videos why he thinks object-oriented programming is a bad idea to begin with and he finishes up the series with a couple of notes on how non-OOP code should be written.</li>
</ul>
<p><a href="http://codersatwork.com/">Coders at work - Reflections on the Craft of Programming</a></p>
<ul>
<li>Based on nearly eighty hours of conversations with fifteen all-time great programmers and computer scientists, the Q&amp;A interviews in Coders at Work provide a multifaceted view into how great programmers learn to program, how they practice their craft, and what they think about the future of programming.</li>
</ul>
<p><a href="https://www.oreilly.com/ideas/the-traits-of-a-proficient-programmer">The traits of a proficient programmer</a></p>
<ul>
<li>Competence means having enough experience and knowledge to get stuff done; proficiency involves knowing why you are doing something in a certain way, and how it fits into the big picture. In other words, a proficient practitioner is always a competent practitioner, but the opposite may not be true.</li>
</ul>
<p><a href="https://www.owasp.org/images/0/08/OWASP_SCP_Quick_Reference_Guide_v2.pdf">OWASP Secure Coding Guidelines</a></p>
<ul>
<li>This technology agnostic document defines a set of general software security coding practices, in a checklist format, that can be integrated into the software development life-cycle. Implementation of these practices will mitigate most common software vulnerabilities.</li>
</ul>
<p><a href="https://www.owasp.org/index.php/Security_by_Design_Principles">Security by Design Principles</a></p>
<ul>
<li>Web application security is an essential component of any successful project, whether open source PHP applications, web services such as straight through processing, or proprietary business web sites. Hosters (rightly) shun insecure code, and users shun insecure services that lead to fraud. The aim of this Development Guide is to allow businesses, developers, designers and solution architects to produce secure web applications. If done from the earliest stages, secure applications cost about the same to develop as insecure applications, but are far more cost effective in the long run.</li>
</ul>
<p><a href="http://phpsecurity.readthedocs.io/en/latest/">Survive The Deep End: PHP Security</a></p>
<ul>
<li>As every target of a serious security breach will quickly note in their press releases and websites: Security is very important to them and take it very seriously. Taking this sentiment to heart before you learn it the hard way is recommended.</li>
</ul>
<p><a href="https://openlibrary.org/books/OL7407595M/Refactoring">Refactoring Improving the Design of Existing Code</a></p>
<ul>
<li>Refactoring is about improving the design of existing code. It is the process of changing a software system in such a way that it does not alter the external behavior of the code, yet improves its internal structure. With refactoring you can even take a bad design and rework it into a good one. This book offers a thorough discussion of the principles of refactoring, including where to spot opportunities for refactoring, and how to set up the required tests. There is also a catalog of more than 40 proven refactorings with details as to when and why to use the refactoring, step by step instructions for implementing it, and an example illustrating how it works. The book is written using Java as its principle language, but the ideas are applicable to any OO language.</li>
</ul>
<p><a href="https://openlibrary.org/works/OL15333872W/The_Practice_of_Programming_%28Addison-Wesley_Professional_Computing_Series%29">The Practice of Programming</a></p>
<ul>
<li>A compendium of practical matters of importance to working programmers.</li>
</ul>
<p><a href="https://openlibrary.org/works/OL5748544W/The_pragmatic_programmer">The pragmatic programmer</a></p>
<ul>
<li>The Pragmatic Programmer: From Journeyman to Master examines the core programming process: taking a requirement and producing working, maintainable code that delights its users. It covers topics ranging from personal responsibility and career development to architectural techniques for keeping code flexible, easy to adapt, and reuse.</li>
</ul>
<p><a href="https://openlibrary.org/works/OL1875800W/Understanding_programming_languages">Understanding programming languages</a></p>
<ul>
<li>The choice of a programming language is one of the most important factors that influence the ultimate quality of a software system. Unfortunately, too many programmers have poor linguistic skills: they are passionately in love with their “native” language, but are not able to analyze language constraints. “Understanding Programming Languages” is written for the purpose of explaining what alternatives are available to the language designer; how language constructs should be used in terms of safety and readability; how language constructs are implemented and which ones can be efficiently complied; and what is the role of language in expressing and enforcing abstractions.</li>
</ul>
<h1 id="como-contribuir">Como contribuir</h1>
<p>Contribua no <a href="https://github.com/unixsheikh/phpthewrongway">GitHub</a>.</p>
<ul>
<li>Clone e edite.</li>
<li>Envie uma pull request para apreciação.</li>
</ul>
<p>Adicione seções no diretório <em>sections/LANGUAGE</em> ou edite uma seção existente.</p>
</body>
</html>
